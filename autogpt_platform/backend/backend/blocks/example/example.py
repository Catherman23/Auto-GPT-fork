import logging

from pydantic import BaseModel

from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema
from backend.data.model import APIKeyCredentials, CredentialsField, SchemaField

from ._api import ExampleClient
from ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, ExampleCredentialsInput

logger = logging.getLogger(__name__)


class GreetingMessage(BaseModel):
    message: str
    is_funny: bool


class ExampleBlock(Block):

    class Input(BlockSchema):
        name: str = SchemaField(
            description="The name of the example block", placeholder="Enter a name"
        )
        greetings: list[str] = SchemaField(
            description="The greetings to display", default=["Hello", "Hi", "Hey"]
        )
        is_funny: bool = SchemaField(
            description="Whether the block is funny",
            placeholder="True",
            default=True,
            # Advanced fields are moved to the "Advanced" dropdown in the UI
            advanced=True,
        )
        greeting_context: str = SchemaField(
            description="The context of the greeting",
            placeholder="Enter a context",
            default="The user is looking for an inspirational greeting",
            # Hidden fields are not shown in the UI at all
            hidden=True,
        )
        # Only if the block needs credentials
        credentials: ExampleCredentialsInput = CredentialsField(
            description="The credentials for the example block"
        )

    class Output(BlockSchema):
        response: GreetingMessage = SchemaField(
            description="The response object generated by the example block."
        )
        all_responses: list[GreetingMessage] = SchemaField(
            description="All the responses from the example block."
        )
        greeting_count: int = SchemaField(
            description="The number of greetings in the input."
        )
        error: str = SchemaField(description="The error from the example block")

    def __init__(self):
        super().__init__(
            # The unique identifier for the block, this value will be persisted in the DB.
            # It should be unique and constant across the application run.
            # Use the UUID format for the ID.
            id="380694d5-3b2e-4130-bced-b43752b70de9",
            # The description of the block, explaining what the block does.
            description="The example block",
            # The set of categories that the block belongs to.
            # Each category is an instance of BlockCategory Enum.
            categories={BlockCategory.BASIC},
            # The schema, defined as a Pydantic model, for the input data.
            input_schema=ExampleBlock.Input,
            # The schema, defined as a Pydantic model, for the output data.
            output_schema=ExampleBlock.Output,
            # The list or single sample input data for the block, for testing.
            # This is an instance of the Input schema with sample values.
            test_input={
                "name": "Craig",
                "greetings": ["Hello", "Hi", "Hey"],
                "is_funny": True,
                "credentials": TEST_CREDENTIALS_INPUT,
            },
            # The list or single expected output if the test_input is run.
            # Each output is a tuple of (output_name, output_data).
            test_output=[
                ("response", GreetingMessage(message="Hello, world!", is_funny=True)),
                (
                    "response",
                    GreetingMessage(message="Hello, world!", is_funny=True),
                ),  # We mock the function
                (
                    "response",
                    GreetingMessage(message="Hello, world!", is_funny=True),
                ),  # We mock the function
                (
                    "all_responses",
                    [
                        GreetingMessage(message="Hello, world!", is_funny=True),
                        GreetingMessage(message="Hello, world!", is_funny=True),
                        GreetingMessage(message="Hello, world!", is_funny=True),
                    ],
                ),
                ("greeting_count", 3),
            ],
            # Function names on the block implementation to mock on test run.
            # Each mock is a dictionary with function names as keys and mock implementations as values.
            test_mock={
                "my_function_that_can_be_mocked": lambda *args, **kwargs: GreetingMessage(
                    message="Hello, world!", is_funny=True
                )
            },
            # The credentials required for testing the block.
            # This is an instance of APIKeyCredentials with sample values.
            test_credentials=TEST_CREDENTIALS,
        )

    def my_function_that_can_be_mocked(
        self, name: str, credentials: APIKeyCredentials
    ) -> GreetingMessage:
        logger.info("my_function_that_can_be_mocked called with input: %s", name)

        # Use the ExampleClient from _api.py to make an API call
        client = ExampleClient(credentials=credentials)

        # Create a sample resource using the client
        resource_data = {"name": name, "type": "greeting"}
        # If your API response object matches the return type of the function,
        # there is no need to convert the object. In this case we have a different
        # object type for the response and the return type of the function.
        return GreetingMessage(**client.create_resource(resource_data).model_dump())

    def run(
        self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs
    ) -> BlockOutput:
        """
        The run function implements the block's core logic. It processes the input_data
        and yields the block's output.

        In addition to credentials, the following parameters can be specified:
            graph_id: The ID of the graph containing this block.
            node_id: The ID of this block's node in the graph.
            graph_exec_id: The ID of the current graph execution.
            node_exec_id: The ID of the current node execution.
            user_id: The ID of the user executing the block.
        """
        rtn_all_responses: list[GreetingMessage] = []
        # Here we deomonstrate best practice for blocks that need to yield multiple items.
        # We yield each item from the list to allow for operations on each element.
        # We also yield the complete list for situations when the full list is needed.
        for greeting in input_data.greetings:
            message = self.my_function_that_can_be_mocked(greeting, credentials)
            rtn_all_responses.append(message)
            yield "response", message
        yield "all_responses", rtn_all_responses
        yield "greeting_count", len(input_data.greetings)
